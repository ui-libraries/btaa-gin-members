<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTAA GIN Member Institutions</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <style>
        /* Add any additional CSS styles here */
        body, html {
            margin: 0;
            overflow: hidden;
        }       
    </style>
</head>
<body>

<script src="https://d3js.org/d3.v6.min.js"></script>
<script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

<script>
    // Set up the dimensions of the SVG container
    const width = window.innerWidth,
        height = window.innerHeight;

    // Create an SVG container
    const svg = d3.create("svg")
        .attr("viewBox", [0, -30, width, height]);

    // Define a projection (you can choose a different projection as needed)
    const projection = d3.geoMercator()
        .center([-85.5,42.7]) // Center the map
        .scale(2000)      // Zoom level
        .translate([width / 2, height / 2]);


    //const projection = d3.geoAlbersUsa().scale(3000).translate([50, 550]);

    // Create a path generator
    const path = d3.geoPath().projection(projection);

    // Load GeoJSON files
    Promise.all([
        d3.json('data/all-states.json'),
        d3.json('data/btaa-states.json'),
        d3.json('data/na-lakes.json'),
        d3.json('data/ocean.json'),
        d3.json('data/btaa-universities.json')
    ]).then(([allStates, uniStates, naLakes, ocean, unis]) => {

        // Rewind with Turf
        validUniStates = uniStates.features.map(d=>turf.rewind(d,{reverse:true}));
        validLakes = naLakes.features.map(d=>turf.rewind(d,{reverse:true}));
        validOcean = ocean.features.map(d=>turf.rewind(d,{reverse:true}));
            
        // Append a new SVG path element for each state
        svg.selectAll(".uni-state-path")
            .data(validUniStates)
            .enter().append("path")
            .attr("fill", "#0088CE")
            .attr("fill-opacity", 0.90)
            .attr("stroke", "black")
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 0.0)
            .attr("d", path);

        // Append a new SVG path element for each state
        svg.selectAll(".state-path")
            .data(allStates.features)
            .enter().append("path")
            .attr("fill", "none")
            .attr("fill-opacity", 0.0)
            .attr("stroke", "gray")
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 0.75)
            .attr("d", path); 

        // Append a new SVG path element for each state
        svg.selectAll(".na-lakes-path")
            .data(validLakes)
            .enter().append("path")
            .attr("fill", "#0088CE")
            .attr("fill-opacity", 0.20)
            .attr("stroke", "gray")
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 0.0)
            .attr("d", path);  

        // Append a new SVG path element for each state
        svg.selectAll(".oceans-path")
            .data(validOcean)
            .enter().append("path")
            .attr("fill", "#0088CE")
            .attr("fill-opacity", 0.20)
            .attr("stroke", "gray")
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 0.0)
            .attr("d", path);
            
        // Create a force simulation
        const simulation = d3.forceSimulation(unis.features)
            .force("x", d3.forceX(d => projection(d.geometry.coordinates)[0]).strength(0.1))
            .force("y", d3.forceY(d => projection(d.geometry.coordinates)[1]).strength(0.1))
            .force("collide", d3.forceCollide().radius(12).strength(1)) // Adjust radius and strength as needed
            .stop(); // Stop the simulation to manually set initial positions
        
        // Run the simulation for a few ticks to resolve collisions and finalize positions
        for (let i = 0; i < 300; ++i) simulation.tick();
        
        // Bind data and create circle elements
        svg.selectAll("circle")
            .data(unis.features)
            .enter().append("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", 12)
            .attr("stroke", "#163b58")
            .attr("stroke-width", 0.5)
            .attr("fill-opacity", 0.75)
            .attr("fill", "white") // Change the fill color as needed
            // Define hover effects for circles
            .on("mouseover", function() { 
                d3.select(this)
                    .attr("stroke", "yellow") // Change stroke to yellow
                    .attr("stroke-width", 1.0); // Widen stroke
            })
            .on("mouseout", function() { 
                d3.select(this)
                    .attr("stroke", "#163b58") // Change stroke back to gray
                    .attr("stroke-width", 0.5); // Change stroke back to 0.5
            })
            // For each state...
            .each(function (d) {
            // Set the tooltip content as follows...
            tippy(this, {
                content: `${d.properties.name}`,
                allowHTML: true,
                theme: "light",
            });
            });  

        // Bind data and create text elements associated with circles
        svg.selectAll("text")
            .data(unis.features)
            .enter().append("text")
            .attr("x", d => d.x)
            .attr("y", d => d.y)
            .text(d => d.properties.id)
            .attr("text-anchor", "middle")
            .attr("dy", 5) // Adjust the vertical position of the label as needed
            .style("fill", "black") // Change the text color as needed
            .style("pointer-events", "none"); // Prevent the text from triggering pointer events                   

        // Append the SVG to the body
        document.body.appendChild(svg.node()); 
  
    });
</script>

</body>
</html>